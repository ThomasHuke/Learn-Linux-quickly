# 查找文件
[目录](./summary.md)
## 基本命令
- locate – 通过名字来查找文件
- find – 在目录层次结构中搜索文件
- xargs – 从标准输入生成和执行命令行
- touch – 更改文件时间
- stat – 显示文件或文件系统状态

## locate 和find对比
### 介绍
- locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。
一般情况我们只需要输入 locate your_file_name 即可查找指定文件。

- find命令是linux系统查找文件的命令，最大的作用是帮助用户在使用linux 系统时候能快速的找出自己所需要的文件

### 他们是不同的。
locate与find 不同: find 是去硬盘找，locate 只在/var/lib/slocate资料库中找。
locate的速度比find快，它并不是真的查找，而是查数据库，一般文件数据库在/var/lib/slocate/slocate.db中，所以locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为：locate -u
### 安全
locate查找时，连一些系统关键性位置的文件都可以找出，然而find会受到权限方面的限制，所以同样的过滤条件，locate查找出的文件数量要明显多于find查找出的数量，所以在安全性上locate较find要略逊一筹。

###突然想说说grep和其它命令的配合。
例如locate和find把。grep自己是无法进行文件搜索的，意思就是它对于整个硬盘进行搜索，它能做的是对于给它的输入流就行搜索，什么意思呢看下面皆是

 find file_name | sort |grep zip
 什么意思呢 file_name查询全局然后输入流就是整个系统，输出流就是给了sort等sort已经排序好了以后呢然后又把输出流给到grep，这时候grep才能发挥效果，因为grep是处理输入流的，它自己不主动去查找硬盘，你要给它值才可以的。

### 还有一点 > 重定向和|的关系

 只能加文件或者目录文件，不能跟命令，而 |是命令之间的流传递，最大的区别是
 - 一个是命令输出的流流向了文件
 - 一个是命令和命令之间的交流。

### find的优势
locate 程序只能依据文件名来查找文件，而 find 程序能基于各种各样的属性， 搜索一个给定目录（以及它的子目录），来查找文件。
### wc  和find结合
find file_name | wc 计算文件的大小

## 重点介绍find
- find menu_name -type tye_name

|文件类型	|描述|
|---|---|
|b|	块设备文件|
|c|	字符设备文件|
|d	|目录|
|f	|普通文件|
|l|	符号链接|

find还可以根据很多东西来查找目录中的文件内容（通常我们都是查找目录文件而不是普通文件）
```bash
find ~ -tye f -name "*.jpg" -zie +1M |wc
```
### -size 支持的单位
|b|	512 个字节块。如果没有指定单位，则这是默认值。|
|---|---|
|c|	字节|
|w|	两个字节的字|
|k|	千字节(1024个字节单位)|
|M|	兆字节(1048576个字节单位)|
|G	|千兆字节(1073741824个字节单位)|

```bash
man find
```
使用man来查看全部的参数。

## 操作符
其实这个东西就是你有很多命令了然后对于命令进行一个规范，就是宏

|字符的内容|解释|
|------|---|
|-and|如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。 注意若没有使用操作符，则默认使用 -and。|
|-or|若操作符两边的任一个测试条件为真，则匹配真的那部分。可以简写为 -o。|
|-not|操作符后面的测试条件是真，则匹配。可以简写为一个感叹号（!）。|
|()|	把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。 默认情况下，find 命令按照从左到右的顺序计算。经常有必要重写默认的求值顺序，以得到期望的结果。 即使没有必要，有时候包括组合起来的字符，对提高命令的可读性是很有帮助的。注意 因为圆括号字符对于 shell 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 find 命令。通常反斜杠字符被用来转义圆括号字符。|

```bash
find ~ \( -type f ! -perm 600\) -o \(-type d ! -perm 0700\)
```
> 记得()要转移，就是要（）的意思而不是其它意思。

因为圆括号对于 shell 有特殊含义，我们必须转义它们，来阻止 shell 解释它们

> 关于or，它的意思是两边一个为真一个为假，并不是一个或者两个为真，是只能一个是真的，看下面一个列表：

|expr1|	符号|expr2|
|---|---|---|
|真	|-and|	总要执行|
|假	|-and	|从不执行|
|真	|-or	|从不执行|
|假	|-or	|总要执行|

### find的几个参数

|操作|描述|
|-|-|
|-delete|	删除当前匹配的文件。|
|-ls|对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。
|-print|	把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。
|-quit	|一旦找到一个匹配，退出。

### 警告⚠️

使用 find -delete时，是执行的删除命令，而不是删除并显示其余不删除的部分，但是删除的并没有真实删除命令，而是真的就是删除了。

```bash
cd ~/Desktop/
> ffff.md
> fdfdf.jpg
> fdfdf.text
find ~/Desktop -type f -name '*.jpg' -delete
ls
app.md		fdfdf.text	lin
code		ffff.md		linshi.md

```
观察来看，.jpg就是没有了，这个命令也是很好用的，而且我认为比rm 或者是rmdir更加精确灵活。

## xargs
传说中的参数小王子
它的作用是什么呢，我来举个例子吧

假说说是前面是pwd，后面是ls，使用|可以吗？ls接受的是参数，ls不能接受一个输入流，xargs就可以将输入流改成参数。

的确是有些命令就是从输入流获取信息到输出流，但是有些不能，

其实我个人一般使用 ls $(commond)这个我比较习惯，有种返回值的感觉。

我们应该注意，如果一个命令输入进去没有进入输入框(> ....)那么它的参数就不是输入流，就是参数需要在后面输入，不能从输入端获取，这时候使用`返回值`,就OK了，也就是 $()，当然xargs就是让一个输入流变成参数的神奇工具。

## touch命令有两个功能：
一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。
